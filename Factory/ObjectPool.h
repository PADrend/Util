/*
	This file is part of the Util library.
	Copyright (C) 2020 Sascha Brandt <myeti@mail.upb.de>
	
	This library is subject to the terms of the Mozilla Public License, v. 2.0.
	You should have received a copy of the MPL along with this library; see the 
	file LICENSE. If not, you can obtain one at http://mozilla.org/MPL/2.0/.
*/
#ifndef UTIL_FACTORY_OBJECTPOOL_H
#define UTIL_FACTORY_OBJECTPOOL_H

#include "FallbackPolicies.h"
#include "../Utils.h"

#include <unordered_map>
#include <deque>

namespace Util {
	
//! @addtogroup factory
//! @{

/**
 * @brief Generic object pool for objects.
 *
 * The pool template can be instaniated to generate different kinds of pools.
 * The generated pool generates and pools objects of type @a ObjectType.
 * It hashes the parameters used to create an object and stores it in a map.
 * If an object with the same hash already exists, it is returned instead of creating a new one.
 *
 * @tparam ObjectType Base type for all objects that are generated by the factory
 * @tparam IdentifierType Type of the identifier that specifies which object pool to call
 * @tparam FallbackPolicy Template with a function @a onUnknownType() that handles the case that the requested object type was not found
 */
template < class ObjectType,
		 typename IdentifierType,
		 typename ObjectCreator = std::function<ObjectType ()>,
		 template<class, typename> class FallbackPolicy = FallbackPolicies::ExceptionFallback >
class ObjectPool {
	private:
		typedef std::deque<ObjectType> pool_t;
		struct Pool final {
			Pool(const ObjectCreator& creator) : creator(creator) {}
			ObjectCreator creator;
			pool_t pool;
		};
		typedef std::unordered_map<IdentifierType, Pool> registrations_t;
		registrations_t registrations;
	public:
		typedef FallbackPolicy<ObjectType, IdentifierType> fallbackPolicy_t;
		fallbackPolicy_t fallbackPolicy;
		ObjectPool() : fallbackPolicy() { }
		ObjectPool(fallbackPolicy_t policy) : fallbackPolicy(policy) { }
		~ObjectPool() = default;

		void registerType(const IdentifierType& id, ObjectCreator creator) {
			auto it = registrations.find(id);
			if(it != registrations.end()) 
				throw std::invalid_argument("the pool already exists");
			registrations.emplace(id, creator);
		}

		void unregisterType(const IdentifierType& id) {
			registrations.erase(id);
		}

		bool hasType(const IdentifierType& id) {
			return registrations.find(id) != registrations.end();
		}

		ObjectType create(const IdentifierType& id) {
			auto it = registrations.find(id);
			if(it == registrations.end()) 
				return fallbackPolicy.onUnknownType(std::bind(&ObjectPool::create, this, std::placeholders::_1), id);
			if(it->second.pool.empty())
				return (it->second.creator)();
			auto obj = it->second.pool.front();
			it->second.pool.pop_front();
			return obj;
		}

		void free(const IdentifierType& id, const ObjectType& obj) {
			auto it = registrations.find(id);
			if(it != registrations.end())
				it->second.pool.emplace_back(obj);
		}

		void reset() {
			for(auto& entry : registrations)
				entry.second.pool.clear();
		}
};

//! @}

}

#endif /* UTIL_FACTORY_OBJECTPOOL_H */
